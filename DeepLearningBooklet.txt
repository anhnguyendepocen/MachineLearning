Deep Learning with H2O

Arno Candel 
Viraj Parmar 
Erin LeDell 
Anisha Arora 

Edited by: Jessica Lanford

http://h2o.ai/resources/

July 2016: Fifth Edition

Contents

1 Introduction

2 What is H2O?

3 Installation  
3.1 InstallationinR 
3.2 InstallationinPython  
3.3 PointingtoaDifferentH2OCluster  
3.4 ExampleCode  
3.5 Citation  

4 Deep Learning Overview

5 H2O’s Deep Learning Architecture  
5.1 SummaryofFeatures  
5.2 TrainingProtocol  
5.2.1 Initialization  
5.2.2 ActivationandLossFunctions   
5.2.3 Parallel Distributed Network Training  
5.2.4 Specifying the Number of Training Samples  
5.3 Regularization  
5.4 AdvancedOptimization  
5.4.1 MomentumTraining   
5.4.2 RateAnnealing  
5.4.3 AdaptiveLearning  
5.5 LoadingData  
5.5.1 Data Standardization/Normalization  
5.5.2 Convergence-based Early Stopping  
5.5.3 Time-basedEarlyStopping  
5.6 AdditionalParameters

6 Use Case: MNIST Digit Classification  
6.1 MNISTOverview  
6.2 PerformingaTrialRun  
6.2.1 N-foldCross-Validation  
6.2.2 Extracting and Handling the Results  
6.3 WebInterface  
6.3.1 VariableImportances   
6.3.2 JavaModel  
6.4 GridSearchforModelComparison  
6.4.1 CartesianGridSearch  
6.4.2 RandomGridSearch  
6.5 CheckpointModels  
6.6 AchievingWorld-RecordPerformance  
6.7 ComputationalPerformance

7 Deep Autoencoders 
7.1 NonlinearDimensionalityReduction  
7.2 UseCase:AnomalyDetection  
7.2.1 StackedAutoencoder  
7.2.2 Unsupervised Pretraining with Supervised Fine-Tuning 

8 Parameters

9 Common R Commands

10 Common Python Commands

11 References

12 Authors

1 Introduction

This document introduces the reader to Deep Learning with H2O. Examples are written in R and Python. Topics include:

- installation of H2O

- basic Deep Learning concepts

- building deep neural nets in H2O

- how to interpret model output

- how to make predictions

as well as various implementation details.

2 What is H2O?

H2O is fast, scalable, open-source machine learning and deep learning for smarter applications. With H2O, enterprises like PayPal, Nielsen Catalina, Cisco, and others can use all their data without sampling to get accurate predictions faster. Advanced algorithms such as deep learning, boosting, and bagging ensembles are built-in to help application designers create smarter applications through elegant APIs. Some of our initial customers have built powerful domain-specific predictive engines for recommendations, customer churn, propensity to buy, dynamic pricing, and fraud detection for the insurance, healthcare, telecommunications, ad tech, retail, and payment systems industries.

Using in-memory compression, H2O handles billions of data rows in-memory, even with a small cluster. To make it easier for non-engineers to create complete analytic workflows, H2O’s platform includes interfaces for R, Python, Scala, Java, JSON, and CoffeeScript/JavaScript, as well as a built-in web interface, Flow. H2O is designed to run in standalone mode, on Hadoop, or within a Spark Cluster, and typically deploys within minutes.

H2O includes many common machine learning algorithms, such as generalized linear modeling (linear regression, logistic regression, etc.), Na ̈ıve Bayes, principal components analysis, k-means clustering, and others. H2O also implements best-in-class algorithms at scale, such as distributed random forest, gradient boosting, and deep learning. Customers can build thousands of models and compare the results to get the best predictions.

H2O is nurturing a grassroots movement of physicists, mathematicians, and computer scientists to herald the new wave of discovery with data science by collaborating closely with academic researchers and industrial data scientists. Stanford university giants Stephen Boyd, Trevor Hastie, Rob Tibshirani advise the H2O team on building scalable machine learning algorithms. With hundreds of meetups over the past three years, H2O has become a word-of-mouth phenomenon, growing amongst the data community by a hundred-fold, and is now used by 30,000+ users and is deployed using R, Python, Hadoop, and Spark in 2000+ corporations.

Try it out

- Download H2O directly at http://h2o.ai/download.

- Install H2O’s R package from CRAN at https://cran.r-project.org/web/packages/h2o/.

- Install the Python package from PyPI at https://pypi.python.org/pypi/h2o/. 

Join the community

- To learn about our meetups, training sessions, hackathons, and product updates, visit http://h2o.ai.

- Visit the open source community forum at https://groups.google. com/d/forum/h2ostream.

- Join the chat at https://gitter.im/h2oai/h2o-3.

3 Installation

H2O requires Java; if you do not already have Java installed, install it from https://java.com/en/download/ before installing H2O.

The easiest way to directly install H2O is via an R or Python package.

3.1 Installation in R

To load a recent H2O package from CRAN, run:

install.packages("h2o")

Note: The version of H2O in CRAN may be one release behind the current version.

For the latest recommended version, download the latest stable H2O-3 build from the H2O download page:

1. Go to http://h2o.ai/download.

2. Choose the latest stable H2O-3 build.

3. Click the “Install in R” tab.

4. Copy and paste the commands into your R session.

After H2O is installed on your system, verify the installation:

library(h2o)

# Start H2O on your local machine using all available cores.
# By default, CRAN policies limit use to only 2 cores.
h2o.init(nthreads = -1)

# Get help
?h2o.glm
?h2o.gbm
?h2o.deeplearning

# Show a demo
demo(h2o.glm)
demo(h2o.gbm)
demo(h2o.deeplearning)

3.2 Installation in Python

To load a recent H2O package from PyPI, run:

pip install h2o

To download the latest stable H2O-3 build from the H2O download page:
1. Go to http://h2o.ai/download.
2. Choose the latest stable H2O-3 build.
3. Click the “Install in Python” tab.
4. Copy and paste the commands into your Python session.
After H2O is installed, verify the installation:
8 | Installation
1 import h2o 2
3 # Start H2O on your local machine
4 h2o.init()
5
6 # Get help
7 help(h2o.estimators.glm.H2OGeneralizedLinearEstimator)
8 help(h2o.estimators.gbm.H2OGradientBoostingEstimator)
9 help(h2o.estimators.deeplearning.
      H2ODeepLearningEstimator)
10
11 # Show a demo
12 h2o.demo("glm")
13 h2o.demo("gbm")
14 h2o.demo("deeplearning")

3.3 Pointing to a Different H2O Cluster

The instructions in the previous sections create a one-node H2O cluster on your local machine.
To connect to an established H2O cluster (in a multi-node Hadoop environment, for example) specify the IP address and port number for the established cluster using the ip and port parameters in the h2o.init() command. The syntax for this function is identical for R and Python:
1 h2o.init(ip = "123.45.67.89", port = 54321)

3.4 Example Code

R and Python code for the examples in this document can be found here:
https://github.com/h2oai/h2o-3/tree/master/h2o-docs/src/ booklets/v2_2015/source/DeepLearning_Vignette_code_examples
The document source itself can be found here:
https://github.com/h2oai/h2o-3/blob/master/h2o-docs/src/ booklets/v2_2015/source/DeepLearning_Vignette.tex

3.5 Citation

To cite this booklet, use the following:
Candel, A., Parmar, V., LeDell, E., and Arora, A. (Jul 2016). Deep Learning
with H2O. http://h2o.ai/resources.

4 Deep Learning Overview

Unlike the neural networks of the past, modern Deep Learning provides training stability, generalization, and scalability with big data. Since it performs quite well in a number of diverse problems, Deep Learning is quickly becoming the algorithm of choice for the highest predictive accuracy.
The first section is a brief overview of deep neural networks for supervised learning tasks. There are several theoretical frameworks for Deep Learning, but this document focuses primarily on the feedforward architecture used by H2O.
The basic unit in the model (shown in the image below) is the neuron, a biologically inspired model of the human neuron. In humans, the varying strengths of the neurons’ output signals travel along the synaptic junctions and are then aggregated as input for a connected neuron’s activation.
In the model, the weighted combination α = 􏰋ni=1 wixi + b of input signals is aggregated, and then an output signal f (α) transmitted by the connected neuron. The function f represents the nonlinear activation function used throughout the network and the bias b represents the neuron’s activation threshold.
Multi-layer, feedforward neural networks consist of many layers of interconnected neuron units (as shown in the following image), starting with an input layer to match the feature space, followed by multiple layers of nonlinearity, and ending with a linear regression or classification layer to match the output space.
Deep Learning Overview | 9

10 | H2O’s Deep Learning Architecture
The inputs and outputs of the model’s units follow the basic logic of the single neuron described above.
Bias units are included in each non-output layer of the network. The weights linking neurons and biases with other neurons fully determine the output of the entire network. Learning occurs when these weights are adapted to minimize the error on the labeled training data. More specifically, for each training example j, the objective is to minimize a loss function,
L(W,B | j).
Here, W is the collection {Wi}1:N−1, where Wi denotes the weight matrix connecting layers i and i + 1 for a network of N layers. Similarly B is the collection {bi}1:N−1, where bi denotes the column vector of biases for layer i+1.
This basic framework of multi-layer neural networks can be used to accomplish Deep Learning tasks. Deep Learning architectures are models of hierarchical feature extraction, typically involving multiple levels of nonlinearity. Deep Learning models are able to learn useful representations of raw data and have exhibited high performance on complex data such as images, speech, and text (Bengio, 2009).

5 H2O’s Deep Learning Architecture

H2O follows the model of multi-layer, feedforward neural networks for predictive modeling. This section provides a more detailed description of H2O’s Deep Learning features, parameter configurations, and computational implementation.

H2O’s Deep Learning Architecture | 11

5.1 Summary of Features

H2O’s Deep Learning functionalities include:

- supervised training protocol for regression and classification tasks

- fast and memory-efficient Java implementations based on columnar com- pression and fine-grain MapReduce

- multi-threaded and distributed parallel computation that can be run on a single or a multi-node cluster

- automatic, per-neuron, adaptive learning rate for fast convergence

- optional specification of learning rate, annealing, and momentum options

- regularization options such as L1, L2, dropout, Hogwild!, and model averaging to prevent model overfitting

- elegant and intuitive web interface (Flow)

- fully scriptable R API from H2O’s CRAN package

- fully scriptable Python API

- grid search for hyperparameter optimization and model selection

- automatic early stopping based on convergence of user-specified metrics to user-specified tolerance

- model checkpointing for reduced run times and model tuning

- automatic pre- and post-processing for categorical and numerical data

- automatic imputation of missing values (optional)

- automatic tuning of communication vs computation for best performance

- model export in plain Java code for deployment in production environments

- additional expert parameters for model tuning

- deep auto encoders for unsupervised feature learning and anomaly detection

12 | H2O’s Deep Learning Architecture

5.2 Training Protocol

The training protocol described below follows many of the ideas and advances discussed in recent Deep Learning literature.

5.2.1 Initialization

Various Deep Learning architectures employ a combination of unsupervised pre-training followed by supervised training, but H2O uses a purely supervised training protocol. The default initialization scheme is the uniform adaptive option, which is an optimized initialization based on the size of the network. Deep Learning can also be started using a random initialization drawn from either a uniform or normal distribution, optionally specifying a scaling parameter.

5.2.2 Activation and Loss Functions

The choices for the nonlinear activation function f described in the introduction are summarized in Table 1 below. xi and wi represent the firing neuron’s input values and their weights, respectively; α denotes the weighted combination α = 􏰋i wixi + b.
Function
Table 1: Activation Functions Formula
Range
f(·)∈[−1,1] f (·) ∈ R+ f(·) ∈ R
Tanh Rectified Linear Maxout
f(α)= eα−e−α eα +e−α
f (α) = max(0, α) f(α1, α2) = max(α1, α2)
The tanh function is a rescaled and shifted logistic function; its symmetry around 0 allows the training algorithm to converge faster. The rectified linear activation function has demonstrated high performance on image recognition tasks and is a more biologically accurate model of neuron activations (LeCun et al, 1998).
Maxout is a generalization of the Rectifiied Linear activation, where each neuron picks the largest output of k separate channels, where each channel has its own weights and bias values. The current implementation supports only k = 2. Maxout activation works particularly well with dropout (Goodfellow et al, 2013). For more information, refer to Regularization.
H2O’s Deep Learning Architecture | 13
The Rectifier is the special case of Maxout where the output of one channel is always 0. It is difficult to determine a “best” activation function to use; each may outperform the others in separate scenarios, but grid search models can help to compare activation functions and other parameters. For more information, refer to Grid Search for Model Comparison. The default activation function is the Rectifier. Each of these activation functions can be operated with dropout regularization. For more information, refer to Regularization.
Specify the one of the following distribution functions for the response variable using the distribution argument:

- AUTO

- Bernoulli

- Multinomial

- Poisson 

- Gamma 

- Tweedie

- Laplace

- Quantile

- Huber

- Gaussian

Each distribution has a primary association with a particular loss function, but some distributions allow users to specify a non-default loss function from the group of loss functions specified in Table 2. Bernoulli and multinomial are primarily associated with cross-entropy (also known as log-loss), Gaussian with Mean Squared Error, Laplace with Absolute loss (a special case of Quantile with quantile alpha=0.5) and Huber with Huber loss. For Poisson, Gamma, and Tweedie distributions, the loss function cannot be changed, so loss must be set to AUTO.
The system default enforces the table’s typical use rule based on whether regression or classification is being performed. Note here that t(j) and o(j) are the predicted (also known as target) output and actual output, respectively, for training example j; further, let y represent the output units and O the output layer.
Function Mean Squared Error Absolute
Huber Cross Entropy
Table 2: Loss functions Formula
L(W, B|j) = 1 ∥t(j) − o(j)∥2 22
L(W, B|j) = ∥t(j) − o(j)∥1
Typical use Regression Regression
Regression Classification
􏰊1∥t(j)−o(j)∥2 2 2
∥t(j) − o(j)∥1 − 1 2
􏰋 􏰂 (j) (j) ln(oy ) · ty
y∈O
for∥t(j)−o(j)∥1 ≤1, otherwise.
(j) (j) 􏰃 + ln(1 − oy ) · (1 − ty )
L(W, B|j) = L(W, B|j) = −
To predict the 80-th percentile of the petal length of the Iris dataset in R, use the following:
14 | H2O’s Deep Learning Architecture

Example in R

1 2 3
4 5 6 7 8
1 2
3 4
5 6
7 8
library(h2o)
h2o.init(nthreads = -1)
train.hex <- h2o.importFile("https://h2o-public-test-
   data.s3.amazonaws.com/smalldata/iris/iris_wheader.
   csv")
splits <- h2o.splitFrame(train.hex, 0.75, seed=1234)
dl <- h2o.deeplearning(x=1:3, y="petal_len",
        training_frame=splits[[1]],
        distribution="quantile", quantile_alpha=0.8)
h2o.predict(dl, splits[[2]])
To predict the 80-th percentile of the petal length of the Iris dataset in Python, use the following:
Example in Python
import h2o
from h2o.estimators.deeplearning import
   H2ODeepLearningEstimator
h2o.init()
train = h2o.import_file("https://h2o-public-test-data.
   s3.amazonaws.com/smalldata/iris/iris_wheader.csv")
splits = train.split_frame(ratios=[0.75], seed=1234)
dl = H2ODeepLearningEstimator(distribution="quantile",
    quantile_alpha=0.8)
dl.train(x=range(0,2), y="petal_len", training_frame=
   splits[0])
print(dl.predict(splits[1]))

H2O’s Deep Learning Architecture | 15

5.2.3 Parallel Distributed Network Training

The process of minimizing the loss function L(W, B | j) is a parallelized version of stochastic gradient descent (SGD). A summary of standard SGD provided below, with the gradient ∇L(W,B | j) computed via backpropagation (LeCun et al, 1998). The constant α is the learning rate, which controls the step sizes during gradient descent.
Standard stochastic gradient descent
1. Initialize W, B
2. Iterate until convergence criterion reached:
a. Get training example i
b. Update all weights wjk ∈ W, biases bjk ∈ B
wjk :=wjk −α∂L(W,B|j) ∂wjk
bjk :=bjk −α∂L(W,B|j) ∂bjk
Stochastic gradient descent is fast and memory-efficient but not easily paral- lelizable without becoming slow. We utilize Hogwild!, the recently developed lock-free parallelization scheme from Niu et al, 2011, to address this issue.
Hogwild! follows a shared memory model where multiple cores (where each core handles separate subsets or all of the training data) are able to make independent contributions to the gradient updates ∇L(W, B | j) asynchronously.
In a multi-node system, this parallelization scheme works on top of H2O’s distributed setup that distributes the training data across the cluster. Each node operates in parallel on its local data until the final parameters W, B are obtained by averaging.

16 | H2O’s Deep Learning Architecture
Parallel distributed and multi-threaded training with SGD in H2O Deep Learning
1. Initialize global model parameters W, B
2. Distribute training data T across nodes (can be disjoint or replicated) 3. Iterate until convergence criterion reached:
3.1. For nodes n with training subset Tn, do in parallel:
a. Obtain copy of the global model parameters Wn,Bn b. Select active subset Tna ⊂ Tn
(user-given number of samples per iteration) c. Partition Tna into Tnac by cores nc
d. For cores nc on node n, do in parallel:
i. Get training example i ∈ Tnac
ii. Update all weights wjk ∈ Wn, biases bjk ∈ Bn
wjk :=wjk −α∂L(W,B|j) ∂wjk
bjk :=bjk −α∂L(W,B|j) ∂bjk
3.2. Set W, B := Avgn Wn, Avgn Bn
3.3. Optionally score the model on (potentially sampled)
train/validation scoring sets
Here, the weights and bias updates follow the asynchronous Hogwild! proce- dure to incrementally adjust each node’s parameters Wn,Bn after seeing the example i. The Avgn notation represents the final averaging of these local parameters across all nodes to obtain the global model parameters and complete training.

H2O’s Deep Learning Architecture | 17

5.2.4 Specifying the Number of Training Samples

H2O Deep Learning is scalable and can take advantage of large clusters of compute nodes. There are three operating modes. The default behavior allows every node to train on the entire (replicated) dataset but automatically shuffling (and/or using a subset of) the training examples for each iteration locally.
For datasets that don’t fit into each node’s memory (depending on the amount of heap memory specified by the -Xmx Java option), it might not be possible to replicate the data, so each compute node can be specified to train only with local data. An experimental single node mode is available for cases where final convergence is slow due to the presence of too many nodes, but this has not been necessary in our testing.
To specify the global number of training examples shared with the distributed SGD worker nodes between model averaging, use the
train samples per iteration parameter. If the specified value is -1, all nodes process all their local training data on each iteration.
If replicate training data is enabled, which is the default setting, this will result in training N epochs (passes over the data) per iteration on N nodes; otherwise, one epoch will be trained per iteration. Specifying 0 always results in one epoch per iteration regardless of the number of compute nodes. In general, this parameter supports any positive number. For large datasets, we recommend specifying a fraction of the dataset.
A value of -2, which is the default value, enables auto-tuning for this parameter based on the computational performance of the processors and the network of the system and attempts to find a good balance between computation and communication. This parameter can affect the convergence rate during training.
For example, if the training data contains 10 million rows, and the number of training samples per iteration is specified as 100,000 when running on four nodes, then each node will process 25, 000 examples per iteration, and it will take 40 distributed iterations to process one epoch.
If the value is too high, it might take too long between synchronization and model convergence may be slow. If the value is too low, network communication overhead will dominate the runtime and computational performance will suffer.

18 | H2O’s Deep Learning Architecture

5.3 Regularization

H2O’s Deep Learning framework supports regularization techniques to prevent overfitting. l1(L1: Lasso) and l2 (L2: Ridge) regularization enforce the same penalties as they do with other models: modifying the loss function so as to minimize loss:
L′(W, B | j) = L(W, B | j) + λ1R1(W, B | j) + λ2R2(W, B | j).
For l1 regularization, R1(W,B | j) is the sum of all l1 norms for the weights and biases in the network; l2 regularization via R2(W,B | j) represents the sum of squares of all the weights and biases in the network. The constants λ1 and λ2 are generally specified as very small (for example 10−5).
The second type of regularization available for Deep Learning is a modern innovation called dropout (Hinton et al., 2012). Dropout constrains the online optimization so that during forward propagation for a given training example, each neuron in the network suppresses its activation with probability P , which is usually less than 0.2 for input neurons and up to 0.5 for hidden neurons.
There are two effects: as with l2 regularization, the network weight values are scaled toward 0. Although they share the same global parameters, each training example trains a different model. As a result, dropout allows an exponentially large number of models to be averaged as an ensemble to help prevent overfitting and improve generalization.
If the feature space is large and noisy, specifying an input dropout using the input dropout ratio parameter can be especially useful. Note that in- put dropout can be specified independently of the dropout specification in the hidden layers (which requires activation to be TanhWithDropout, MaxoutWithDropout, or RectifierWithDropout). Specify the amount of hidden dropout per hidden layer using the hidden dropout ratios pa- rameter, which is set to 0.5 by default.

5.4 Advanced Optimization

H2O features manual and automatic advanced optimization modes. The manual mode features include momentum training and learning rate annealing and the automatic mode features an adaptive learning rate.

H2O’s Deep Learning Architecture | 19

5.4.1 Momentum Training

Momentum modifies back-propagation by allowing prior iterations to influence the current version. In particular, a velocity vector, v, is defined to modify the updates as follows:

- θ represents the parameters W, B

- μ represents the momentum coefficient 􏰀 α represents the learning rate
vt+1 = μvt − α∇L(θt) θt+1 = θt + vt+1
Using the momentum parameter can aid in avoiding local minima and any associated instability (Sutskever et al, 2014). Too much momentum can lead to instability, so we recommend incrementing the momentum slowly. The pa- rameters that control momentum are momentum start, momentum ramp, and momentum stable.
When using momentum updates, we recommend using the Nesterov acceler- ated gradient method, which uses the nesterov accelerated gradient parameter. This method modifies the updates as follows:
vt+1 = μvt − α∇L(θt + μvt) Wt+1 = Wt + vt+1

5.4.2 Rate Annealing

During training, the chance of oscillation or “optimum skipping” creates the need for a slower learning rate as the model approaches a minimum. As opposed to specifying a constant learning rate α, learning rate annealing gradually reduces the learning rate αt to “freeze” into local minima in the optimization landscape (Zeiler, 2012).
For H2O, the annealing rate (rate annealing) is the inverse of the number of training samples required to divide the learning rate in half (e.g., 10−6 means that it takes 106 training samples to halve the learning rate).

20 | H2O’s Deep Learning Architecture

5.4.3 Adaptive Learning

The implemented adaptive learning rate algorithm ADADELTA (Zeiler, 2012) automatically combines the benefits of learning rate annealing and momentum training to avoid slow convergence. To simplify hyper parameter search, specify only ρ and ε.
In some cases, a manually controlled (non-adaptive) learning rate and momen- tum specifications can lead to better results but require a hyperparameter search of up to seven parameters. If the model is built on a topology with many local minima or long plateaus, a constant learning rate may produce sub-optimal results. However, the adaptive learning rate generally produces the best results during our testing, so this option is the default.
The first of two hyper parameters for adaptive learning is ρ (rho). It is similar to momentum and is related to the memory of prior weight updates. Typical values are between 0.9 and 0.999. The second hyper parameter, ε (epsilon), is similar to learning rate annealing during initial training and allows further progress during momentum at later stages. Typical values are between 10−10 and 10−4.

5.5 Loading Data

Loading a dataset in R or Python for use with H2O is slightly different than the usual methodology. Instead of using data.frame or data.table in R, or pandas.DataFrame or numpy.array in Python, datasets must be converted into H2OFrame objects (distributed data frames).

5.5.1 Data Standardization/Normalization

Along with categorical encoding, H2O’s Deep Learning preprocesses the data to standardize it for compatibility with the activation functions (refer to to the summary of each activation function’s target space in Activation Functions).
Since the activation function generally does not map into the full spectrum of real numbers, R, we first standardize our data to be drawn from N(0,1). Standardizing again after network propagation allows us to compute more precise errors in this standardized space, rather than in the raw feature space.
For autoencoding, the data is normalized (instead of standardized) to the compact interval of U(−0.5,0.5) to allow bounded activation functions like tanh to better reconstruct the data.
H2O’s Deep Learning Architecture | 21

5.5.2 Convergence-based Early Stopping

Early stopping based on convergence of a user-specified metric is an especially helpful feature for finding the optimal number of epochs. By default, it uses the metrics on the validation dataset, if provided. Otherwise, training metrics are used.

- To stop model building if misclassification improves (is reduced) by less than one percent between individual scoring epochs, specify stopping rounds=1, stopping tolerance=0.01 and stopping metric="misclassification".

- To stop model building if the simple moving average (window length 5) if the AUC improves (increases) by less than 0.1 percent for 5 consecutive scoring epochs, use stopping rounds=5, stopping metric="AUC", and stopping tolerance=0.001.

- To stop model building if the logloss on the validation set does not improve at all for 3 consecutive scoring epochs, specify a validation frame, stopping rounds=3, stopping tolerance=0 and
stopping metric="logloss".

- To continue model building even after metrics have converged, disable this feature using stopping rounds=0.

- To compute the best number of epochs with cross-validation, simply specify stopping rounds>0 as in the examples above, in combination with nfolds>1, and the main model will pick the ideal number of epochs from the convergence behavior of the nfolds cross-validation models.

5.5.3 Time-based Early Stopping

To stop model training after a given amount of seconds, specify max runtime secs > 0. This option is also available for grid searches and models with cross- validation. Note: The model(s) will likely end up with fewer epochs than specified by epochs.

5.6 Additional Parameters

Since there are dozens of possible parameter arguments when creating models, configuring H2O Deep Learning models may seem daunting. However, most parameters do not need to be modified; the default settings are recommended for most use cases.

22 | Use Case: MNIST Digit Classification
There is no general rule for setting the number of hidden layers, their sizes or the number of epochs. Experimenting by building Deep Learning models using different network topologies and different datasets will lead to insights about these parameters.
For pointers on specific values and results for these (and other) parameters, many example tests are available in the H2O GitHub repository. For a full list of H2O Deep Learning model parameters and default values, refer to Parameters.

6 Use Case: MNIST Digit Classification

The following use case describes how to use H2O’s Deep Learning for classifica- tion of handwritten numerals.

6.1 MNIST Overview

The MNIST database is a well-known academic dataset used to benchmark classification performance. The data consists of 60,000 training images and 10,000 test images. Each image is a standardized 282 pixel greyscale image of a single handwritten digit. An example of the scanned handwritten digits is shown in Figure 1.
Figure 1: Example MNIST digit images
This example downloads and imports the training and testing datasets from a public Amazon S3 bucket (https://h2o-public-test-data.s3.

Use Case: MNIST Digit Classification | 23
amazonaws.com/bigdata/laptopt/mnist/train.csv.gz and same for test.csv.gz). The training file is 13MB and the testing file is 2.1MB. The data is downloaded directly, so the data import speed is dependent on download speed. Files can be imported from a variety of sources, including local file systems or shared file systems such as NFS, S3 and HDFS.
24 | Use Case: MNIST Digit Classification

Example in R

To run the MNIST example in R, use the following:
1 library(h2o) 2
3 # Sets number of threads to number of available cores
4 h2o.init(nthreads = -1)
5
6 train_file <- "https://h2o-public-test-data.s3.
      amazonaws.com/bigdata/laptop/mnist/train.csv.gz"
7 test_file <- "https://h2o-public-test-data.s3.
      amazonaws.com/bigdata/laptop/mnist/test.csv.gz"
8
9 train <- h2o.importFile(train_file)
10 test <- h2o.importFile(test_file)
11
12 # Get a brief summary of the data
13 summary(train)
14 summary(test)

Example in Python

To run the MNIST example in Python, use the following:
1 import h2o 2
3 # Start H2O cluster with all available cores (default)
4 h2o.init()
5
6 train = h2o.import_file("https://h2o-public-test-data.
      s3.amazonaws.com/bigdata/laptop/mnist/train.csv.gz
")
7 test = h2o.import_file("https://h2o-public-test-data.
      s3.amazonaws.com/bigdata/laptop/mnist/test.csv.gz"
)
9 # Get a brief summary of the data
10 train.describe()
11 test.describe()
8

Use Case: MNIST Digit Classification | 25

6.2 Performing a Trial Run

The example below illustrates how the default settings provide the relative simplicity underlying most H2O Deep Learning model parameter configurations. The first 282 = 784 values of each row represent the full image and the final value denotes the digit class.
Rectified linear activation is popular with image processing and has previously performed well on the MNIST database. Dropout has been known to enhance performance on this dataset as well, so we train our model accordingly.
To perform the trial run in R, use the following:

Example in R

1 # Specify the response and predictor columns
2 y <- "C785"
3 x <- setdiff(names(train), y)
4
5 # Encode the response column as categorical for multinomial classification
6 train[,y] <- as.factor(train[,y])
7 test[,y] <- as.factor(test[,y])
8
9 # Train Deep Learning model and validate on test set
10 model <- h2o.deeplearning(
11 x = x,
12 y = y,
13 training_frame = train,
14 validation_frame = test,
15 distribution = "multinomial",
16 activation = "RectifierWithDropout",
17 hidden = c(32,32,32),
18 input_dropout_ratio = 0.2,
19 sparse = TRUE,
20 l1 = 1e-5,
21 epochs = 10)

26 | Use Case: MNIST Digit Classification
To perform the trial run in Python, use the following:

Example in Python

1 from h2o.estimators.deeplearning import H2ODeepLearningEstimator
2
3 # Specify the response and predictor columns
4 y = "C785"
5 x = train.names[0:784]
6
7 # Encode the response column as categorical for
      multinomial classification
8 train[y] = train[y].asfactor()
9 test[y] = test[y].asfactor()
10
11 # Train Deep Learning model and validate on test set
12 model = 13
14
15
H2ODeepLearningEstimator(
distribution="multinomial",
activation="RectifierWithDropout",
hidden=[32,32,32],
input_dropout_ratio=0.2,
sparse=True,
16 17 18 19
20 model.train(
21 x=x,
22 y=y,
23 training_frame=train,
24 validation_frame=test)
l1=1e-5,
epochs=10)
The model runs for only 10 epochs since it is just meant as a trial run. In this trial run, we also specified the validation set as the test set. In addition to (or instead of) using a validation set, another option to estimate generalization error is N-fold cross-validation.
Use Case: MNIST Digit Classification | 27

6.2.1 N-fold Cross-Validation

If the value specified for nfolds is a positive integer, N-fold cross-validation is performed on the training frame and the cross-validation metrics are com- puted and stored as model output. To disable cross-validation, use nfolds=0, which is the default value.
To save the predicted values generated during cross-validation, set the
keep cross validation predictions parameter to true. This enables calculation of custom cross-validated performance metrics for the R or Python model.
Advanced users can also specify a fold column that specifies the holdout fold associated with each row. By default, the holdout fold assignment is random, but other schemes such as round-robin assignment using the modulo operator are also supported.
To run the cross-validation example in R, use the following:

Example in R

1 2 3 4 5 6 7 8 9
10 11 12 13
# Perform 5-fold cross-validation on training_frame model_cv <- h2o.deeplearning(
        x = x,
        y = y,
        training_frame = train,
        distribution = "multinomial",
activation = "RectifierWithDropout",
hidden = c(32,32,32),
input_dropout_ratio = 0.2,
sparse = TRUE,
l1 = 1e-5,
epochs = 10,
nfolds = 5)

28 | Use Case: MNIST Digit Classification
To run the cross-validation example in Python, use the following:

Example in Python

1 2 3 4 5 6 7 8 9
10 11 12 13 14
# Perform 5-fold cross-validation on training_frame
model_cv = H2ODeepLearningEstimator(
        distribution="multinomial",
        activation="RectifierWithDropout",
hidden=[32,32,32],
input_dropout_ratio=0.2,
sparse=True,
l1=1e-5,
epochs=10,
nfolds=5)
model_cv.train(
        x=x,
        y=y,
        training_frame=train)

6.2.2 Extracting and Handling the Results

We can now extract the parameters of our model, examine the scoring process, and make predictions on new data. The h2o.performance function in R returns all pre-computed performance metrics for the training/validation set or returns cross-validated metrics for the training set, depending on model configuration.
An equivalent model performance method is available in Python, as well as utility functions that return specific metrics, such as mean square error (MSE) or area under curve (AUC). Examples shown below use the previously-trained model and model cv objects.

To view the model results in Python, use the following:

Example in Python

Use Case: MNIST Digit Classification | 29
To view the model results in R, use the following:

Example in R

1 2 3 4 5 6 7 8
9 10 11 12 13 14
1 # View specified parameters of the Deep Learning model
2 model.params
3
4 # Examine the performance of the trained model
5 model # display all performance metrics
6
7 model.model_performance(train=True) # training
metrics
8 model.model_performance(valid=True) # validation
metrics
9
10 # Get MSE only
11 model.mse(valid=True)
12
13 # Cross-validated MSE
14 model_cv.mse(xval=True)
# View specified parameters of the deep learning model
model@parameters
# Examine the performance of the trained model model # display all performance metrics
h2o.performance(model) # training metrics h2o.performance(model, valid = TRUE) # validation
metrics
# Get MSE only
h2o.mse(model, valid = TRUE)
# Cross-validated MSE
h2o.mse(model_cv, xval = TRUE)

30 | Use Case: MNIST Digit Classification
The training error value is based on the parameter score training samples, which specifies the number of randomly sampled training points used for scoring (the default value is 10,000 points). The validation error is based on the parameter score validation samples, which configures the same value on the validation set (by default, this is the entire validation set).
In general, choosing a greater number of sampled points leads to a better understanding of the model’s performance on your dataset; setting either of these parameters to 0 automatically uses the entire corresponding dataset for scoring. However, either method allows you to control the minimum and maximum time spent on scoring with the score interval and score duty cycle parameters.
If the parameter overwrite with best model is enabled, these scoring parameters also affect the final model. This option selects the model that achieved the lowest validation error during training (based on the sampled points used for scoring) as the final model after training. If a dataset is not specified as the validation set, the training data is used by default; in this case, either the score training samples or score validation samples parameter will control the error computation during training and consequently, which model is selected as the best model.
Once we have a satisfactory model (as determined by the validation or cross- validation metrics), use the h2o.predict() command to compute and store predictions on new data for additional refinements in the interactive data science process.
To view the predictions in R, use the following:

Example in R

1 2 3 4 5 6
# Classify the test set (predict class labels)
# This also returns the probability for each class pred <- h2o.predict(model, newdata = test)
# Take a look at the predictions
head(pred)

Use Case: MNIST Digit Classification | 31
￼To view the predictions in Python, use the following:

Example in Python

1 2 3 4 5 6
# Classify the test set (predict class labels)
# This also returns the probability for each class
pred = model.predict(test)
# Take a look at the predictions
pred.head()

6.3 Web Interface

H2O R users have access to an intuitive web interface for H2O, Flow, to mirror the model building process in R. After loading data or training a model in R, point your browser to your IP address and port number (e.g., localhost:54321) to launch the web interface. From here, you can click on Admin > Jobs to view specific details about your model. You can also click on Data > List All Frames to view all current H2O frames.
H2O Python users can connect to Flow the same way as R users: launch an instance of H2O, then launch your browser and enter localhost:54321 (or your custom IP address) in the address bar. Python users can also use iPython notebook to run examples. Launch iPython notebook in Terminal using ipython notebook, and a browser window should automatically launch the iPython interface. Otherwise, launch your browser and enter localhost:8888 in the address bar.

6.3.1 Variable Importances

To enable variable importances, setting the variable importances to true. This feature allows us to view the absolute and relative predictive strength of each feature in the prediction task. Each H2O algorithm class has its own methodology for computing variable importance.
H2O’s Deep Learning uses the Gedeon method (Gedeon, 1997), which is disabled by default since it can be slow for large networks. If variable importance is a top priority in your analysis, consider training a Distributed Random Forest (DRF) model and comparing the generated variable importances.

32 | Use Case: MNIST Digit Classification
The following code demonstrates training using the variable importances option and extracting the variable importances from the trained model. From the web UI, you can also view a visualization of the variable importances.

Example in R

To generate variable importances in R, use the following:
1 # Train Deep Learning model and validate on test set
2 # and save the variable importances
3 model_vi <- h2o.deeplearning(
4 x = x,
5 y = y,
6 training_frame = train,
7 distribution = "multinomial",
8 activation = "RectifierWithDropout",
9 hidden = c(32,32,32),
10 input_dropout_ratio = 0.2,
11 sparse = TRUE,
12 l1 = 1e-5,
13 validation_frame = test,
14 epochs = 10,
15 variable_importances = TRUE)
16
17 # Retrieve the variable importance
18 h2o.varimp(model_vi)

Example in Python

To generate variable importances in Python, use the following:
1 2 3 4 5 6 7 8 9
10 11 12 13 14
# Train Deep Learning model and validate on test set
# and save the variable importances
model_vi = H2ODeepLearningEstimator(
        distribution="multinomial",
        activation="RectifierWithDropout",
        hidden=[32,32,32],
        input_dropout_ratio=0.2,
sparse=True,
l1=1e-5,
epochs=10,
variable_importances=True)
model_vi.train(
x=x,
Use Case: MNIST Digit Classification | 33
y=y,
training_frame=train,
       validation_frame=test)
# Retrieve the variable importance
model_vi.varimp()
15 16 17 18 19 20

6.3.2 Java Model

To access Java code to use to build the current model in Java, click the Preview POJO button at the bottom of the model results. This button generates a POJO model that can be used in a Java application independently of H2O.
To download the model:
1. Open the terminal window.
2. Create a directory where the model will be saved.
3. Set the new directory as the working directory.
4. Follow the curl and java compile commands displayed in the instructions at the top of the Java model.
For more information on how to use an H2O POJO, refer to the POJO Quick Start Guide at https://github.com/h2oai/h2o-3/blob/master/ h2o-docs/src/product/howto/POJO_QuickStart.md.

6.4 Grid Search for Model Comparison

H2O supports model tuning in grid search by allowing users to specify sets of values for parameter arguments and observe changes in model behavior. An example in R is provided below; the Python grid search API is currently in development.
In this example, three different network topologies and two different l1 norm weights are specified. This grid search model trains six different models using all possible combinations of these parameters; other parameter combinations can be specified for a larger space of models. Note that the models will most likely converge before the default value of epochs, since early stopping is enabled.
Grid search provides more subtle insights into the model tuning and selection process by inspecting and comparing our trained models after the grid search
34 | Use Case: MNIST Digit Classification
process is complete. To learn how and when to select different parameter configurations in a grid search, refer to Parameters for parameter descriptions and configurable values.

6.4.1 Cartesian Grid Search

To run a Cartesian hyper-parameter grid search in R, use the following:

Example in R

1 hidden_opt <- list(c(32,32), c(32,16,8), c(100))
2 l1_opt <- c(1e-4,1e-3)
3 hyper_params <- list(hidden = hidden_opt, l1 = l1_opt)
4
5 model_grid <- h2o.grid("deeplearning",
6 grid_id = "mygrid",
7 hyper_params = hyper_params,
8 x = x,
9 y = y,
10 distribution = "multinomial",
11 training_frame = train,
12 validation_frame = test,
13 score_interval = 2,
14 epochs = 1000,
15 stopping_rounds = 3,
16 stopping_tolerance = 0.05,
17 stopping_metric = "misclassification")
To run a Cartesian hyper-parameter grid search in Python, use the following:

Example in Python

1 2 3 4 5 6 7 8 9
hidden_opt = [[32,32],[32,16,8],[100]]
l1_opt = [1e-4,1e-3]
hyper_parameters = {"hidden":hidden_opt, "l1":l1_opt}
from h2o.grid.grid_search import H2OGridSearch
model_grid = H2OGridSearch(H2ODeepLearningEstimator,
    hyper_params=hyper_parameters)
model_grid.train(x=x, y=y,
distribution="multinomial", epochs=1000,
Example in Python
Use Case: MNIST Digit Classification | 35
training_frame=train, validation_frame=test,
score_interval=2, stopping_rounds=3,
stopping_tolerance=0.05,
stopping_metric="misclassification")
10 11 12 13
1
2 3 4 5 6 7 8
1 2 3 4 5
To view the results of the grid search, use the following:

Example in R

# print out all prediction errors and run times of the
    models
model_grid
# print out the Test MSE for all of the models
for (model_id in model_grid@model_ids) {
  mse <- h2o.mse(h2o.getModel(model_id), valid = TRUE)
  print(sprintf("Test set MSE: %f", mse))
}
# print model grid search results
model_grid
for model in model_grid:
    print model.model_id + " mse: " + str(model.mse())

6.4.2 Random Grid Search

If the search space is too large (i.e., you don’t want to restrict the parameters too much), you can also let the Grid Search make random model selections for you. Just specify how many models (and/or how much training time) you want, and a seed to make the random selection deterministic:

Example in R

hidden_opt = lapply(1:100, function(x)10+sample(50,
   sample(4), replace=TRUE))
l1_opt = seq(1e-6,1e-3,1e-6)
1 2
36 | Use Case: MNIST Digit Classification
3 hyper_params <- list(hidden = hidden_opt, l1 = l1_opt)
4 search_criteria = list(strategy = "RandomDiscrete",
5 max_models = 10, max_runtime_secs = 100,
6 seed=123456)
7
8 model_grid <- h2o.grid("deeplearning",
9 grid_id = "mygrid",
10 hyper_params = hyper_params,
11 search_criteria = search_criteria,
12 x = x,
13 y = y,
14 distribution = "multinomial",
15 training_frame = train,
16 validation_frame = test,
17 score_interval = 2,
18 epochs = 1000,
19 stopping_rounds = 3,
20 stopping_tolerance = 0.05,
21 stopping_metric = "misclassification")
Example in Python
1
2 hidden_opt =
      [[17,32],[8,19],[32,16,8],[100],[10,10,10,10]]
3 l1_opt = [s/1e6 for s in range(1,1001)]
4 hyper_parameters = {"hidden":hidden_opt, "l1":l1_opt}
5 search_criteria = {"strategy":"RandomDiscrete",
6 "max_models":10, "max_runtime_secs":100,
7 "seed":123456}
8
9 from h2o.grid.grid_search import H2OGridSearch
10 model_grid = H2OGridSearch(H2ODeepLearningEstimator,
11 hyper_params=hyper_parameters,
12 search_criteria=search_criteria)
13 model_grid.train(x=x, y=y,
14 distribution="multinomial", epochs=1000,
15 training_frame=train, validation_frame=test,
16 score_interval=2, stopping_rounds=3,
17 stopping_tolerance=0.05,
18 stopping_metric="misclassification")

Use Case: MNIST Digit Classification | 37

6.5 Checkpoint Models

To resume model training, use checkpoint model keys (model id) to incremen- tally train a specific model using more iterations, more data, different data, and so forth. To further train the initial model, use it (or its key) as a checkpoint argument for a new model.
To get the best possible model in a general multi-node setup, we recommend building a model with train samples per iteration=-2 (default, auto- tuning) and saving it to disk so that youll have at least one saved model.
To improve this initial model, start from the previous model and add iterations by building another model, specifying checkpoint=previous model id, and changing train samples per iteration, target ratio comm to comp, or other parameters. Many parameters can be changed between checkpoints, especially those that affect regularization or performance tuning.
Checkpoint restart suggestions:
1. For multi-node only: Leave train samples per iteration=-2, increase target ratio comm to comp from 0.05 to 0.25 or 0.5 (more communication). This should lead to a better model when using multiple nodes. Note: No affect on single-node performance at all, since there is no actual communication needed.
2. For both single and multi-node (bagging-like): Explicitly set
train samples per iteration=N, where N is the number of train- ing samples for the whole cluster to train with for one iteration. Each of the n nodes will then train on N/n randomly chosen rows for each iteration. Obviously, a good choice for N depends on the dataset size and the model complexity. Refer to the logs to see what values of N are used in option 1 (when auto-tuning is enabled). Typically, option 1 is sufficient.
3. For both single and multi-node: Change regularization parameters such as l1, l2, max w2, input dropout ratio, hidden dropout ratios. For best results, build the first model with RectifierWithDropout and input dropout ratio=0 and hidden dropout ratios of all 0s, just to be able to enable dropout regularization later. Hidden dropout is often used for initial models, since it often improves general- ization. Input dropout is especially useful if there is some noise in the input.

38 | Use Case: MNIST Digit Classification
Options 1 and 3 should result in a good model. Of course, grid search can be used with checkpoint restarts to scan a broad range of good continuation models.
In the R example below, model grid@model ids[[1]] represents the highest-performing model from the grid search used for additional training. For checkpoint restarts, the response column, training, and validation datasets must match. In addition, the model architecture, such as hidden = c(32,32,32) in the example below, must match.
To restart training in R using a checkpoint model, use the following:

Example in R

1 # Re-start the training process on a saved DL model
2 # using the ‘checkpoint‘ argument
3 model_chkp <- h2o.deeplearning(
4 x = x,
5 y = y,
6 training_frame = train,
7 validation_frame = test,
8 distribution = "multinomial",
9 checkpoint = model@model_id,
10 activation = "RectifierWithDropout",
11 hidden = c(32,32,32),
12 input_dropout_ratio = 0.2,
13 sparse = TRUE,
14 l1 = 1e-5,
15 epochs = 20)
The Python example uses the “trial run” model as the checkpoint model.

Example in Python

1 2 3 4 5 6 7 8 9
# Re-start the training process on a saved DL model
# using the ‘checkpoint‘ argument
model_chkp = H2ODeepLearningEstimator(
        checkpoint=model,
        distribution="multinomial",
        activation="RectifierWithDropout",
        hidden=[32,32,32],
        input_dropout_ratio=0.2,
sparse=True,
1
2 3
4 5 6
1
2 3 4 5 6 7 8
To save a model in Python, use the following:

Example in Python

Use Case: MNIST Digit Classification | 39
l1=1e-5,
epochs=20)
model_chkp.train(
        x=x,
        y=y,
        training_frame=train,
        validation_frame=test)
10 11 12 13 14 15 16 17
Checkpointing can also be used to reload existing models that were saved to disk in a previous session. For example, we can save and reload a model by running the following commands.
To save a model in R, use the following:

Example in R

# Specify a model and the file path where it is to be
   saved. If no path is specified, the model will be
   saved to the current working directory
model_path <- h2o.saveModel(object = model,
                            path=getwd(), force = TRUE
)
print(model_path)
# /tmp/mymodel/DeepLearning_model_R_1441838096933
# Specify a model and the file path where it is to be
   saved. If no path is specified, the model will be
   saved to the current working directory
model_path = h2o.save_model(
        model = model,
        #path = "/tmp/mymodel",
force = True)
print model_path
# /tmp/mymodel/DeepLearning_model_python_1441838096933

40 | Use Case: MNIST Digit Classification
After restarting H2O, load the saved model by specifying the host and saved model file path. Note: The saved model must be reloaded using a compatible H2O version (i.e., the same version used to save the model).
To load a saved model in R, use the following:

Example in R

1 2
1 2
Use Case: MNIST Digit Classification | 41
# Load model from disk
saved_model <- h2o.loadModel(model_path)
To load a saved model in Python, use the following:
Example in Python
# Load model from disk
saved_model = h2o.load_model(model_path)
1 2
1 2
To retrieve a model in Python using its key, use the following:
Example in Python
You can also use the following commands to retrieve a model from its H2O key. This is useful if you have created an H2O model using the web interface and want to continue the modeling process in R.
To retrieve a model in R using its key, use the following:
Example in R
# Retrieve model by H2O key
model <- h2o.getModel(model_id = model_chkp@model_id)
# Retrieve model by H2O key
model = h2o.get_model(model_id=model_chkp._id)
6.6 Achieving World-Record Performance
Without distortions, convolutions, or other advanced image processing tech- niques, the best-ever published test set error for the MNIST dataset is 0.83% by Microsoft. After training for 2, 000 epochs (which took about four hours) on four compute nodes, we obtain a test set error of 0.87%.
After training for 8,000 epochs (which took about ten hours) on ten nodes, we obtain a test set error of 0.83%, which is the current world-record, notably achieved using a distributed configuration and with a simple 1-liner from R:
42 | Use Case: MNIST Digit Classification
Example in R
1 2 3 4
5 6 7 8 9
#World Record run used epochs=8000
model <- h2o.deeplearning(x=x, y=y,
        training_frame=train_hex, validation_frame=
test_hex,
activation="RectifierWithDropout",
hidden=c(1024,1024,2048), epochs=10,
input_dropout_ratio=0.2, l1=1e-5, max_w2=10,
train_samples_per_iteration=-1,
classification_stop=-1, stopping_rounds=0)
6.7 Computational Performance
There are many parameters that affect the computational performance of H2O Deep Learning, but the default values should result in good performance for most problems.
An in-depth study of the computational performance characteristics of H2O Deep Learning with complete code examples and results can be found in our blog post, Definitive Performance Tuning Guide for Deep Learning, available at http://h2o.ai/blog/2015/08/deep-learning-performance/.
The parallel scalability of H2O for the MNIST dataset on 1 to 63 compute nodes is shown in the figure below.

7 Deep Autoencoders
This section describes the use of deep autoencoders for Deep Learning.
7.1 Nonlinear Dimensionality Reduction
Previous sections discussed purely supervised Deep Learning tasks. However, Deep Learning can also be used for unsupervised feature learning or, more specifically, nonlinear dimensionality reduction (Hinton et al, 2006).
Based on the diagram of a three-layer neural network with one hidden layer below, if our input data is treated as labeled with the same input values, then the network is forced to learn the identity via a nonlinear, reduced representation of the original data.
This type of algorithm, called a deep autoencoder, has been used extensively for unsupervised, layer-wise pre-training of supervised Deep Learning tasks. Here we discuss the autoencoder’s ability to discover anomalies in data.
7.2 Use Case: Anomaly Detection
For the deep autoencoder model described above, if enough training data resembling some underlying pattern is provided, the network will train itself to easily learn the identity when confronted with that pattern. However, if an anomalous test point does not match the learned pattern, the autoencoder will likely have a high error rate in reconstructing this data, indicating anomalous data.
This framework is used to develop an anomaly detection demonstration using a deep autoencoder. The dataset is an ECG time series of heartbeats and the goal is to determine which heartbeats are outliers. The training data (20 “good” heartbeats) and the test data (training data with 3 “bad” heartbeats appended for simplicity) can be downloaded directly into the H2O cluster, as shown below. Each row represents a single heartbeat.
Deep Autoencoders | 43

44 | Deep Autoencoders
Example in R
1 # Import ECG train and test data into the H2O cluster
2 train_ecg <- h2o.importFile(
3 path = "http://h2o-public-test-data.s3.
              amazonaws.com/smalldata/anomaly/ecg_
              discord_train.csv",
4 header = FALSE,
5 sep = ",")
6 test_ecg <- h2o.importFile(
7 path = "http://h2o-public-test-data.s3.
              amazonaws.com/smalldata/anomaly/ecg_
              discord_test.csv",
8 header = FALSE,
9 sep = ",")
10
11 # Train deep autoencoder learning model on "normal"
12 # training data, y ignored
13 anomaly_model <- h2o.deeplearning(
14 x = names(train_ecg),
15 training_frame = train_ecg,
16 activation = "Tanh",
17 autoencoder = TRUE,
18 hidden = c(50,20,50),
19 sparse = TRUE,
20 l1 = 1e-4,
21 epochs = 100)
22
23 # Compute reconstruction error with the Anomaly
24 # detection app (MSE between output and input layers)
25 recon_error <- h2o.anomaly(anomaly_model, test_ecg)
26
27 # Pull reconstruction error data into R and
28 # plot to find outliers (last 3 heartbeats)
29 recon_error <- as.data.frame(recon_error)
30 recon_error
31 plot.ts(recon_error)
32
33 # Note: Testing = Reconstructing the test dataset
34 test_recon <- h2o.predict(anomaly_model, test_ecg)
35 head(test_recon)

To run the anomaly detection example in Python, use the following:
Example in Python
1 # Import ECG train and test data into the H2O cluster
2 from h2o.estimators.deeplearning import
      H2OAutoEncoderEstimator
3
4 train_ecg = h2o.import_file("http://h2o-public-test-
      data.s3.amazonaws.com/smalldata/anomaly/
      ecg_discord_train.csv")
5 test_ecg = h2o.import_file("http://h2o-public-test-
      data.s3.amazonaws.com/smalldata/anomaly/
      ecg_discord_test.csv")
6 7
8 # Train deep autoencoder learning model on "normal"
9 # training data, y ignored
10 anomaly_model = H2OAutoEncoderEstimator(
11 activation="Tanh",
12 hidden=[50,50,50],
13 sparse=True,
14 l1=1e-4,
15 epochs=100)
16 anomaly_model.train(
17 x=train_ecg.names,
18 training_frame=train_ecg)
19
20 # Compute reconstruction error with the Anomaly
21 # detection app (MSE between output and input layers)
22 recon_error = anomaly_model.anomaly(test_ecg)
23 24
25 # Note: Testing = Reconstructing the test dataset
26 test_recon = anomaly_model.predict(test_ecg)
27 test_recon
Deep Autoencoders | 45

46 | Parameters
7.2.1 Stacked Autoencoder
It can be difficult to obtain convergence for deep autoencoders, especially since H2O attempts to train all layers at once without imposing symmetry conditions on the network topology (arbitrary configuration of layers is allowed). To train a deep autoencoder layer by layer, follow the R code example here:
https://github.com/h2oai/h2o-3/blob/master/h2o-r/tests/ testdir_algos/deeplearning/runit_deeplearning_stacked_ autoencoder_large.R.
7.2.2 Unsupervised Pretraining with Supervised Fine-Tuning
Sometimes, there’s much more unlabeled data than labeled data. It this case, it might make sense to train an autoencoder model on the unlabeled data and then fine-tune the learned model with the available labels. In H2O, you would train an autoencoder model with autoencoder enabled, and then you can transfer its state to a supervised regular Deep Learning model by specifying pretrained autoencoder. You can seen an R example here:
https://github.com/h2oai/h2o-3/blob/master/h2o-r/tests/ testdir_algos/deeplearning/runit_deeplearning_autoencoder_ large.R,
and the corresponding Python example here: https://github.com/ h2oai/h2o-3/blob/master/h2o-py/tests/testdir_algos/deeplearn pyunit_autoencoderDeepLearning_large.py.
8 Parameters
Logical indicates the parameter requires a value of either TRUE or FALSE.

- x: Specifies the vector containing the names of the predictors in the
model. No default.

- y: Specifies the name of the response variable in the model. No default.

- training frame: Specifies an H2OFrame object containing the vari- ables in the model. No default.

- model id: (Optional) Specifies the unique ID associated with the model. If a value is not specified, an ID is generated automatically.
i

- overwrite with best model: Logical. If enabled, overwrites the final model with the best model scored during training. The default is true.

- validation frame: (Optional) Specifies an H2OFrame object repre- senting the validation dataset used for the confusion matrix. If a value is not specified and nfolds = 0, the training data is used by default.

- checkpoint: (Optional) Specifies the model checkpoint (either an H2ODeepLearningModel or a key) from which to resume training.

- autoencoder: Logical. Enables autoencoder. The default is false. Refer to the Deep Autoencoders section for more details.

- pretrained autoencoder: (Optional) Pretrained autoencoder model (either an
H2ODeepLearningModel or a key) to initialize the model state of a supervised DL model with.

- use all factor levels: Logical. Uses all factor levels of categorical variance. Otherwise, omits the first factor level without loss of accuracy. Useful for variable importances and auto-enabled for autoencoder. The default is true. Refer to the Deep Autoencoders section for more details.

- activation: Specifies the nonlinear, differentiable activation function used in the network. The options are Tanh, TanhWithDropout, Rectifier, RectifierWithDropout, Maxout, or MaxoutWithDropout. The default is Rectifier. Refer to the Activation and Loss Functions and Regularization sections for more details.

- hidden: Specifies the number and size of each hidden layer in the model. For example, if c(100,200,100) is specified, a model with 3 hidden layers is generated. The middle hidden layer will have 200 neurons and the first and third hidden layers will have 100 neurons each. The default is c(200,200). For grid search, use the following format: list(c(10,10), c(20,20)). Refer to the section on Performing a Trial Run for more details.

- epochs: Specifies the number of iterations or passes over the training dataset (can be fractional). For initial grid searches, we recommend starting with lower values. The value allows continuation of selected models and can be modified during checkpoint restarts. The default is 10.
Parameters | 47

48 | Parameters

- train samples per iteration: Specifies the number of training samples (globally) per MapReduce iteration. The following special values are also supported:
– 0 (one epoch)
– -1 (all available data including replicated training data); – -2 (auto-tuning; default)
Refer to Specifying the Number of Training Samples for more details.

- seed: Specifies the random seed controls sampling and initialization. Reproducible results are only expected with single-threaded operations (i.e. running on one node, turning off load balancing, and providing a small dataset that fits in one chunk). In general, the multi-threaded asynchronous updates to the model parameters will result in intentional race conditions and non-reproducible results. The default is a randomly generated number.

- adaptive rate: Logical. Enables adaptive learning rate (ADADELTA). The default is true. Refer to Adaptive Learning for more details.

- rho: Specifies the adaptive learning rate time decay factor. This param- eter is similar to momentum and relates to the memory for prior weight updates. Typical values are between 0.9 and 0.999. The default value is 0.99. Refer to Adaptive Learning for more details.

- epsilon: When enabled, specifies the second of two hyperparameters for the adaptive learning rate. This parameter is similar to learning rate annealing during initial training and momentum at later stages where it assists progress. Typical values are between 1e-10 and 1e-4. This parameter is only active if adaptive rate is enabled. The default is 1e-8. Refer to Adaptive Learning for more details.

- rate: Specifies the learning rate, α. Higher values lead to less stable models, while lower values result in slower convergence. The default is 0.005.

- rate annealing: Reduces the learning rate to “freeze” into local minima in the optimization landscape. The annealing learning rate is calculated as (rate) / (1 + rate annealing * N), where N is the number of training samples. It is the inverse of the number of training samples required to cut the learning rate in half. If adaptive learning is disabled, the default value is 1e-6. Refer to Rate Annealing for more details.

- rate decay: Controls the change of learning rate across layers. The learning rate decay factor between layers is calculated as (L-th layer: rate * rate decayˆ (L-1)). If adaptive learning is disabled, the default is 1.0.

- momentum start: Controls the amount of momentum at the beginning of training when adaptive learning is disabled. The default is 0. Refer to Momentum Training for more details.

- momentum ramp: If the value for momentum stable is greater than momentum start, increases momentum for the duration of the learning. The ramp is measured in the number of training samples and can be enabled when adaptive learning is disabled. The default is 1 million (1e6). Refer to Momentum Training for more details.

- momentum stable: Specifies the final momentum value after the num- ber of training samples specified for momentum ramp when adaptive learning is disabled. The training momentum is applied for any additional training. The default is 0. Refer to Momentum Training for more details.

- nesterov accelerated gradient: Logical. Enables the Nesterov accelerated gradient descent method, which is a modification to the traditional gradient descent for convex functions. The method relies on gradient information at various points to build a polynomial approximation that minimizes the residuals in fewer iterations of the descent. This parameter is only active if the adaptive learning rate is disabled. When adaptive learning is disabled, the default is true. Refer to Momentum Training for more details.

- input dropout ratio: Specifies the fraction of the features for each training row to omit from training to improve generalization. The default is 0, which always uses all features. Refer to Regularization for more details.

- hidden dropout ratios: Specifies the fraction of the inputs for each hidden layer to omit from training to improve generalization. The default is 0.5 for each hidden layer. Refer to Regularization for more details.

- l1: Specifies the l1 (L1) regularization, which constrains the absolute value of the weights (can add stability and improve generalization, causes many weights to become 0). The default is 0, for no L1 regularization. Refer to Regularization for more details.

- l2: L2 regularization, which constrains the sum of the squared weights and can add stability and improve generalization by reducing many weights).

􏰀
􏰀
􏰀
􏰀
􏰀
􏰀
􏰀
􏰀
􏰀
􏰀
The default is 0, which disables L2 regularization. Refer to Regularization for more details.

- max w2: Specifies the maximum for the sum of the squared incoming weights for a neuron. This tuning parameter is especially useful for unbound activation functions such as Maxout or Rectifier. The default, which is positive infinity, leaves this maximum unbounded.

- initial weight distribution: Specifies the distribution from which to draw the initial weights. Select Uniform, UniformAdaptive or Normal. The default is UniformAdaptive. Refer to Initialization for more details.

- initial weight scale: Specifies the scale of the distribution func- tion for uniform or normal distributions. For uniform distributions, the values are drawn uniformly from initial weight scale, initial weight scale. For normal distributions, the values are drawn from a normal distribution with a standard deviation of initial weight scale. The default is 1. Refer to Initialization for more details.

- loss: Specifies the loss option: Automatic, CrossEntropy (clas- sification only), Quadratic, Absolute, or Huber. The default is Automatic. Refer to Activation and Loss Functions for more details.

- distribution: Specifies the distribution function of the response: AUTO, bernoulli, multinomial, poisson, gamma, tweedie, laplace, quantile, huber, or gaussian.

- quantile alpha: Desired quantile for quantile regression (from 0.0 to 1.0) when distribution = "quantile". The default is 0.5 (median, same as distribution = "laplace").

- tweedie power: Specifies the Tweedie power when distribution is tweedie. The range is from 1.0 to 2.0.

- score interval: Specifies the minimum time (in seconds) between model scoring. The actual interval is determined by the number of training samples per iteration and the scoring duty cycle. To use all training set samples, specify 0. The default is 5.

- score training samples: Specifies the number of training samples to randomly sample for scoring. To select the entire training dataset, specify 0. The default is 10000.

- score validation samples: Specifies the number of validation dataset points for scoring. Can be randomly sampled or stratified if

Parameters | 51

- balance classes is enabled and score validation sampling is Stratified. To select the entire validation dataset, specify 0, which is the default.

- score duty cycle: Specifies the maximum duty cycle fraction for model scoring on both training and validation samples and diagnostics such as computation of feature importances. Lower values result in more training, while higher values produce more scoring. The default is 0.1.

- classification stop: Specifies the stopping criterion for classifica- tion error (1 - accuracy) on the training data scoring dataset. When the error is at or below this threshold, training stops. The default is 0. To disable, specify -1.

- regression stop: Specifies the stopping criterion for regression error (MSE) on the training data scoring dataset. When the error is at or below this threshold, training stops. The default is 1e-6. To disable, specify -1.

- stopping rounds: Early stopping based on convergence of stopping metric. Stop if simple moving average of length k of the stopping metric does not improve for k:=stopping rounds scoring events. Can only trigger after at least 2k scoring events. To disable, specify 0.

- stopping metric: Metric to use for early stopping (AUTO: logloss for classification, deviance for regression). Can be any of AUTO, deviance, logloss, MSE, AUC, r2, misclassification.

- stopping tolerance: Relative tolerance for metric-based stopping criterion Relative tolerance for metric-based stopping criterion (stop if relative improvement is not at least this much).

- max runtime secs: Maximum allowed runtime in seconds for model training. Use 0 to disable.

- missing values handling: Handling of missing values. Either Skip or MeanImputation (default).

- quiet mode: Logical. Enables quiet mode for less output to standard output. The default is false.

- max confusion matrix size: For classification models, specifies the maximum size (in terms of classes) for displaying the confusion matrix. This option helps avoid printing extremely large confusion matrices. The default is 20.

52 | Parameters

- max hit ratio k: For multi-class only. Specifies the maximum number (top K) of predictions to use for hit ratio computation. To disable, specify 0. The default is 10.

- balance classes: Logical. For imbalanced data, the training data class counts can be artificially balanced by over-sampling the minority classes and under-sampling the majority classes so that each class contains the same number of observations. This can result in improved predictive accuracy. Over-sampling uses replacement, rather than simulating new observations. The max after balance size parameter specifies the total number of observations after balancing. The default is false.

- class sampling factors: Specifies the desired over/under-sampling ratios per class (in lexicographic order). Only applies to classification when balance classes is enabled. If not specified, the ratios are automatically computed to obtain class balancing during training.

- max after balance size: When classes are balanced, limits the resulting dataset size to the specified multiple of the original dataset size. This is the maximum relative size of the training data after balancing class counts and can be less than 1.0. The default is 5.

- score validation sampling: Specifies the method used to sam- ple the validation dataset for scoring. The options are Uniform and Stratified. The default is Uniform.

- variable importances: Logical. Computes variable importances for input features using the Gedeon method. Uses the weights connecting the input features to the first two hidden layers. The default is false, since this can be slow for large networks.

- fast mode: Logical. Enables fast mode, a minor approximation in back-propagation that should not significantly affect results. The default is true.

- ignore const cols: Logical. Ignores constant training columns, since no information can be gained anyway. The default is true.

- force load balance: Logical. Forces extra load balancing to increase training speed for small datasets to keep all cores busy. The default is true.

- replicate training data: Logical. Replicates the entire training dataset on every node for faster training on small datasets. The default is true.

- single node mode: Logical. Runs Deep Learning on a single node for fine-tuning model parameters. Can be useful for faster convergence during checkpoint restarts after training on a very large number of nodes (for fast initial convergence). The default is false.

- shuffle training data: Logical. Shuffles training data on each node. This option is recommended if training data is replicated on N nodes and the number of training samples per iteration is close to N times the dataset size, where all nodes train with almost all of the data. It is automatically enabled if the number of training samples per iteration is set to -1 (or to N times the dataset size or larger). The default is false.

- sparse: Logical. Enables sparse data handling (more efficient for data with lots of 0 values). The default is false.

- col major: (Deprecated) Logical. Uses a column major weight matrix for the input layer; can speed up forward propagation, but may slow down backpropagation. The default is false.

- average activation: Specifies the average activation for the sparse autoencoder (Experimental). The default is 0.

- sparsity beta: Specify the sparsity-based regularization optimization (Experimental). The default is 0.

- max categorical features: Specifies the maximum number of categorical features in a column, enforced via hashing (Experimental). The default is 231 − 1 (Integer.MAX VALUE in Java).

- reproducible: Logical. Forces reproducibility on small data; slow, since it only uses one thread. The default is false.

- export weights and biases: Logical. Exports the neural network weights and biases as an H2OFrame. The default is false.

- offset column: Specifies the offset column by column name. Re- gression only. Offsets are per-row “bias values” that are used during model training. For Gaussian distributions, they can be seen as simple corrections to the response (y) column. Instead of learning to predict the response value directly, the model learns to predict the (row) offset of the response column. For other distributions, the offset corrections are applied in the linearized space before applying the inverse link function to get the actual response values.

- weights column: Specifies the weights column by column name, which must be included in the specified training frame. Python only: To use a weights column when passing an H2OFrame to x instead of a list of column names, the specified training frame must contain the specified weights column. Weights are per-row observation weights. This is typically the number of times a row is repeated, but non-integer values are supported as well. During training, rows with higher weights matter more, due to the larger loss function pre-factor.

- nfolds: (Optional) Specifies the number of folds for cross-validation. The default is 0, which disables cross-validation.

- fold column: (Optional) Specifies the name of the column with the cross-validation fold index assignment per observation; the folds are supplied by the user.

- fold assignment: Specifies the cross-validation fold assignment scheme if nfolds is greater than zero and fold column is not specified. The options are AUTO, Random, Stratified or Modulo.

- keep cross validation predictions: Logical. Specify whether to keep the predictions of the cross-validation models. The default is false.

Common R Commands

- library(h2o): Imports the H2O R package.

- h2o.init(): Connects to (or starts) an H2O cluster.

- h2o.shutdown(): Shuts down the H2O cluster.

- h2o.importFile(path): Imports a file into H2O.

- h2o.deeplearning(x,y,training frame,hidden,epochs): Creates a Deep Learning model.

- h2o.grid(algorithm,grid id,...,hyper params = list()): Starts H2O grid support and gives results.

- h2o.predict(model, newdata): Generate predictions from an H2O model on a test set.

Common Python Commands

- import h2o: Imports the H2O Python package. h2o.init(): Connects to (or starts) an H2O cluster.

- h2o.shutdown(): Shuts down the H2O cluster.

- h2o.import file(path): Imports a file into H2O.

- model = H2ODeepLearningEstimator(hidden, epochs): Creates a Deep Learning model.

- model.train(x, y, training frame): Trains our Deep Learning model.

- h2o.predict(model, newdata): Generate predictions from an H2O model on a test set.
Common Python Commands | 55
56 | References

11 References

Feng Niu, Benjamin Recht, Christopher R, and Stephen J. Wright. Hogwild: A Lock-Free Approach to Parallelizing Stochastic Gradient Descent. In In NIPS, 2011

G. E. Hinton, N. Srivastava, A. Krizhevsky, I. Sutskever, and R. R. Salakhutdi- nov. Improving neural networks by preventing co-adaptation of feature detectors. 2012. URL http://arxiv.org/pdf/1207.0580.pdf

Ilya Sutskever, James Martens, George Dahl, and Geoffrey Hinton. On the importance of initialization and momentum in deep learning. 2014. URL http://www.cs.toronto.edu/ ̃fritz/absps/momentum.pdf

Matthew D. Zeiler. ADADELTA: An Adaptive Learning Rate Method. 2012. URL http://arxiv.org/pdf/1212.5701v1.pdf

Yan LeCun, Corinna Cortes, and Christopher J.C Burgres. The MNIST Database. URL http://yann.lecun.com/exdb/mnist/

G.E. Hinton and R.R. Salakhutdinov. Reducing the Dimensionality of Data with Neural Networks. Science, 313:504–507, 2006. URL http://www.cs.toronto.edu/~hinton/science.pdf

Arno Candel. Definitive Performance Tuning Guide for Deep Learning. http://h2o.ai/blog/2015/02/deep-learning-performance/, 2015

H2O.ai Team. H2O website, 2016. URL http://h2o.ai

H2O.ai Team. H2O documentation, 2016. URL http://docs.h2o.ai

H2O.ai Team. H2O GitHub Repository, 2016. URL https://github. com/h2oai

H2O.ai Team. H2O Datasets, 2016. URL http://data.h2o.ai 

H2O.ai Team. H2O JIRA, 2016. URL https://jira.h2o.ai

H2O.ai Team. H2Ostream, 2016. URL https://groups.google.com/ d/forum/h2ostream

H2O.ai Team. H2O R Package Documentation, 2016. URL http://h2o-release.s3.amazonaws.com/h2o/latest_stable_Rdoc.html

Authors | 57

12 Authors 

Arno Candel

Arno is the Chief Architect of H2O, a distributed and scalable open-source machine learning platform. He is also the main author of H2O Deep Learning. Arno holds a PhD and Masters summa cum laude in Physics from ETH Zurich, Switzerland. He has authored dozens of scientific papers and is a sought-after conference speaker. Arno was named 2014 Big Data All-Star by Fortune Magazine. Follow him on Twitter: @ArnoCandel.

Erin LeDell

Erin is a Statistician and Machine Learning Scientist at H2O.ai. She is the main author of H2O Ensemble. Erin received her Ph.D. in Biostatistics with a Designated Emphasis in Computational Science and Engineering from University of California, Berkeley. Her research focuses on ensemble machine learning, learning from imbalanced binary-outcome data, influence curve based variance estimation and statistical computing. She also holds a B.S. and M.A. in Mathematics.

Viraj Parmar

Viraj is studying applied mathematics at Princeton. Prior to joining H2O.ai as a former data and math hacker intern, Viraj worked in a research group at the MIT Center for Technology and Design. His interests are in software engineering and large-scale machine learning. Apart from work, Viraj enjoys reading, sampling new cuisines, and traveling with his family.

Anisha Arora

Anisha is a software intern who is a senior at Cupertino High School. She enjoys programming and is interested in machine learning. She likes to swim, play the piano and violin, and tutor in science and math subjects at her school.

Jessica Lanford

Jessica is a word hacker and seasoned technical communicator at H2O.ai. She brings our product to life by documenting the many features and functionality of H2O. Having worked for some of the top companies in technology including Dell, AT&T, and Lam Research, she is an expert at translating complex ideas to digestible articles.
